const base64js = require('base64-js');

/**
 * Adapts Scratch 2.0 bitmaps for use in scratch 3.0
 */
class BitmapAdapter {
    /**
     * @param {?function} makeImage HTML image constructor. Tests can provide this.
     * @param {?function} makeCanvas HTML canvas constructor. Tests can provide this.
     */
    constructor (makeImage, makeCanvas) {
        this._makeImage = makeImage ? makeImage : () => new Image();
        this._makeCanvas = makeCanvas ? makeCanvas : () => document.createElement('canvas');
    }

    /**
     * Return a canvas with the resized version of the given image, done using nearest-neighbor interpolation
     * @param {CanvasImageSource} image The image to resize
     * @param {int} newWidth The desired post-resize width of the image
     * @param {int} newHeight The desired post-resize height of the image
     * @returns {HTMLCanvasElement} A canvas with the resized image drawn on it.
     */
    resize (image, newWidth, newHeight) {
        // We want to always resize using nearest-neighbor interpolation. However, canvas implementations are free to
        // use linear interpolation (or other "smooth" interpolation methods) when downscaling:
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1360415
        // It seems we can get around this by resizing in two steps: first width, then height. This will always result
        // in nearest-neighbor interpolation, even when downscaling.
        const stretchWidthCanvas = this._makeCanvas();
        stretchWidthCanvas.width = newWidth;
        stretchWidthCanvas.height = image.height;
        let context = stretchWidthCanvas.getContext('2d');
        context.imageSmoothingEnabled = false;
        context.drawImage(image, 0, 0, stretchWidthCanvas.width, stretchWidthCanvas.height);
        if(image instanceof Image){
            image = this._makeCanvas();
        }
        image.width = newWidth;
        image.height = newHeight;
        context = image.getContext('2d');
        context.imageSmoothingEnabled = false;
        context.drawImage(stretchWidthCanvas, 0, 0, newWidth, newHeight);
        return image;
    }

    /**
     * Scratch 2.0 had resolution 1 and 2 bitmaps. All bitmaps in Scratch 3.0 are equivalent
     * to resolution 2 bitmaps. Therefore, converting a resolution 1 bitmap means doubling
     * it in width and height.
     * @param {!string} dataURI Base 64 encoded image data of the bitmap
     * @param {!function} callback Node-style callback that returns updated dataURI if conversion succeeded
     */
    convertResolution1Bitmap (dataURI, callback) {
        const image = this._makeImage();
        image.src = dataURI;
        image.onload = () => {
            callback(null, this.resize(image, image.width * 2, image.height * 2).toDataURL());
        };
        image.onerror = () => {
            callback('Image load failed');
        };
    }

    /**
     * Given width/height of an uploaded item, return width/height the image will be resized
     * to in Scratch 3.0
     *ï¼ˆ1ï¼‰å¯¹äºŽè§’è‰²ï¼Œå¦‚æžœä¸Šä¼ å›¾ç‰‡é•¿åº¦å’Œå®½åº¦éƒ½æ²¡æœ‰è¶…è¿‡ç”»æ¿1186*667çš„å°ºå¯¸ï¼Œåˆ™æ­£å¸¸å¤§å°ï¼Œåœ¨èˆžå°å±…ä¸­
      ï¼ˆ2ï¼‰å¯¹äºŽè§’è‰²ï¼Œå¦‚æžœä¸Šä¼ å›¾ç‰‡é•¿åº¦å’Œå®½åº¦ä»»ä½•ä¸€ä¸ªè¶…è¿‡äº†ç”»æ¿1186*667çš„å°ºå¯¸ï¼Œåˆ™åˆå§‹çš„æ—¶å€™å¯¹è§’è‰²ç­‰æ¯”ä¾‹ç¼©å°ï¼Œç¼©å°åˆ°ä¸¤ä¸ªè¾¹éƒ½å°äºŽç­‰äºŽç”»æ¿çš„å°ºå¯¸ä¸ºæ­¢
      ï¼ˆ3ï¼‰å¯¹äºŽèƒŒæ™¯ï¼Œå¦‚æžœä¸Šä¼ å›¾ç‰‡é•¿åº¦å’Œå®½åº¦ä»»ä½•ä¸€ä¸ªè¶…è¿‡ç”»æ¿1186*667çš„å°ºå¯¸ï¼Œåˆ™ç­‰æ¯”ä¾‹ç¼©æ”¾ï¼Œç¼©å°åˆ°ä¸¤ä¸ªè¾¹éƒ½å°äºŽç­‰äºŽç”»æ¿çš„å°ºå¯¸çš„ï¼Œæ‰€èƒ½è¾¾åˆ°çš„æœ€å¤§å°ºå¯¸ä¸ºæ­¢
      ï¼ˆ4ï¼‰å¯¹äºŽèƒŒæ™¯ï¼Œå¦‚æžœä¸Šä¼ å›¾ç‰‡é•¿åº¦å’Œå®½åº¦ä»»ä½•ä¸€ä¸ªéƒ½å°äºŽç”»æ¿1186*667çš„å°ºå¯¸ï¼Œåˆ™ç­‰æ¯”ä¾‹æ”¾å¤§ï¼Œæ”¾å¤§åˆ°ä¸¤ä¸ªè¾¹éƒ½å°äºŽç­‰äºŽç”»æ¿çš„å°ºå¯¸ä¸ºæ­¢ï¼Œæ‰€èƒ½è¾¾åˆ°çš„æœ€å¤§å°ºå¯¸ä¸ºæ­¢
     * 
     * @param {!number} oldWidth original width
     * @param {!number} oldHeight original height
     * @param {!boolean} backdrop æ˜¯å¦èƒŒæ™¯
     * @return {object} Array of new width, new height
     */
    getResizedWidthHeight (oldWidth, oldHeight, backdrop) {
        // TODO WSF ä¿®æ”¹ä¸Šä¼ å›¾ç‰‡å¤§å°é™åˆ¶
        const STAGE_WIDTH = window.MAX_STAGE_WIDTH || 1186;
        const STAGE_HEIGHT = window.MAX_STAGE_HEIGHT || 667;
        const imageRatio = oldWidth / oldHeight;

        console.log("ðŸš€ ~ file: bitmap-adapter.js ~ line 70 ~ BitmapAdapter ~ getResizedWidthHeight ~ oldWidth, oldHeight", oldWidth, oldHeight);
        // return {width: STAGE_WIDTH * 2, height: STAGE_HEIGHT * 2};

        // èƒŒæ™¯è¦†ç›–
        if (oldWidth > STAGE_WIDTH || oldHeight > STAGE_HEIGHT || backdrop) {
            let width = STAGE_WIDTH;
            let height = STAGE_WIDTH / imageRatio;

            if (height > STAGE_HEIGHT) {
                height = STAGE_HEIGHT;
                width = height * imageRatio;
            }
            
            return {width: width * 2, height: height * 2};
        }
        return {width: oldWidth, height: oldHeight};
    }

    /**
     * Given bitmap data, resize as necessary.
     * @param {ArrayBuffer | string} fileData Base 64 encoded image data of the bitmap
     * @param {string} fileType The MIME type of this file
     * @returns {Promise} Resolves to resized image data Uint8Array
     */
    importBitmap (fileData, fileType, backdrop = false) {
        let dataURI = fileData;
        if (fileData instanceof ArrayBuffer) {
            dataURI = this.convertBinaryToDataURI(fileData, fileType);
        }
        return new Promise((resolve, reject) => {
            const image = this._makeImage();
            image.src = dataURI;
            image.onload = () => {
                const newSize = this.getResizedWidthHeight(image.width, image.height, backdrop);
                if (newSize.width === image.width && newSize.height === image.height) {
                    // No change
                    resolve(this.convertDataURIToBinary(dataURI));
                } else {
                    const resizedDataURI = this.resize(image, newSize.width, newSize.height).toDataURL();
                    resolve(this.convertDataURIToBinary(resizedDataURI));
                }
            };
            image.onerror = () => {
                reject('Image load failed');
            };
        });
    }

    // TODO consolidate with scratch-vm/src/util/base64-util.js
    // From https://gist.github.com/borismus/1032746
    convertDataURIToBinary (dataURI) {
        const BASE64_MARKER = ';base64,';
        const base64Index = dataURI.indexOf(BASE64_MARKER) + BASE64_MARKER.length;
        const base64 = dataURI.substring(base64Index);
        const raw = window.atob(base64);
        const rawLength = raw.length;
        const array = new Uint8Array(new ArrayBuffer(rawLength));

        for (let i = 0; i < rawLength; i++) {
            array[i] = raw.charCodeAt(i);
        }
        return array;
    }

    convertBinaryToDataURI (arrayBuffer, contentType) {
        return `data:${contentType};base64,${base64js.fromByteArray(new Uint8Array(arrayBuffer))}`;
    }
}

module.exports = BitmapAdapter;
