const Cast = require('../util/cast');

class Scratch3EventBlocks {
    constructor (runtime) {
        /**
         * The runtime instantiating this block package.
         * @type {Runtime}
         */
        this.runtime = runtime;

        this.runtime.on('KEY_PRESSED', key => {
            this.runtime.startHats('event_whenkeypressed', {
                KEY_OPTION: key
            });
            this.runtime.startHats('event_whenkeypressed', {
                KEY_OPTION: 'any'
            });
        });
    }

    /**
     * Retrieve the block primitives implemented by this package.
     * @return {object.<string, Function>} Mapping of opcode to Function.
     */
    getPrimitives () {
        return {
            event_whentouchingobject: this.touchingObject,
            event_broadcast: this.broadcast,
            event_broadcastandwait: this.broadcastAndWait,
            event_whengreaterthan: this.hatGreaterThanPredicate,
            event_next_lesson:this.doNextLesson
        };
    }

    getHats () {
        return {
            event_whenflagclicked: {
                restartExistingThreads: true
            },
            event_whenkeypressed: {
                restartExistingThreads: false
            },
            event_whenthisspriteclicked: {
                restartExistingThreads: true
            },
            event_whentouchingobject: {
                restartExistingThreads: false,
                edgeActivated: true
            },
            event_whenstageclicked: {
                restartExistingThreads: true
            },
            event_whenbackdropswitchesto: {
                restartExistingThreads: true
            },
            event_whengreaterthan: {
                restartExistingThreads: false,
                edgeActivated: true
            },
            event_whenbroadcastreceived: {
                restartExistingThreads: true
            }
        };
    }

    touchingObject (args, util) {
        return util.target.isTouchingObject(args.TOUCHINGOBJECTMENU);
    }

    hatGreaterThanPredicate (args, util) {
        const option = Cast.toString(args.WHENGREATERTHANMENU).toLowerCase();
        const value = Cast.toNumber(args.VALUE);
        switch (option) {
        case 'timer':
            return util.ioQuery('clock', 'projectTimer') > value;
        case 'loudness':
            return this.runtime.audioEngine && this.runtime.audioEngine.getLoudness() > value;
        }
        return false;
    }

    getQueryString(flag){
        var reg = new RegExp("(^|&)"+ flag +"=([^&]*)(&|$)");
        var r = window.location.search.substr(1).match(reg);
        if(r!=null) return  unescape(r[2]); 
        return null;
    }

    stringTrim(str){
        return str.replace(/(^\s*)|(\s*$)/g, "");    
    }

    broadcast (args, util) {
        var checkCount = sessionStorage.getItem("checkCount") ? sessionStorage.getItem("checkCount") : 0;
        var practiceId = this.getQueryString('practiceId');
        var scriptFlag = this.getQueryString('scriptFlag');
        if(this.stringTrim(args.BROADCAST_OPTION.name) === '练习完成继续学习'){
            scriptFlag!=='T'&&window.showGemAnimation("practiceAward",true);
            var app = parent.window.apps;
            if(app){
                app.practiceEnd(checkCount);
            }

            if (window.webkit && window.webkit.messageHandlers) {
                var jsonDict = {
                    "act" : 'scratchFinish',
                    "totalTries" : checkCount
                };
                //注意，iOS的postMessage方法只接收一个参数，如果传多个参数，那么WKScriptMessage的body只接收到第一个参数
                 window.webkit.messageHandlers.scratchFinish.postMessage(jsonDict);
            }
        }

        if(typeof practiceId != "undefined" && practiceId != null && practiceId != ""&&scriptFlag!=='T'){
            if(this.stringTrim(args.BROADCAST_OPTION.name) === '练习完成继续学习'){
                window.showGemAnimation("practiceAward",true);
                window.handleCompleteExercise()
            }
        }

        if(this.stringTrim(args.BROADCAST_OPTION.name) === 'z再接再厉'){
            window.winhandlePlayGuide(false,false);
            if(window.parent&&window.parent["succeed"]){
                window.parent["succeed"]();
            }
        }

        if(this.stringTrim(args.BROADCAST_OPTION.name) === '结果正确'){
            window.listenBroadcast(true);
        }

        const broadcastVar = util.runtime.getTargetForStage().lookupBroadcastMsg(
            args.BROADCAST_OPTION.id, args.BROADCAST_OPTION.name);
        if (broadcastVar) {
            const broadcastOption = broadcastVar.name;
            util.startHats('event_whenbroadcastreceived', {
                BROADCAST_OPTION: broadcastOption
            });
        }
    }

    broadcastAndWait (args, util) {
        var practiceId = this.getQueryString('practiceId');
        var checkCount = sessionStorage.getItem("checkCount") ? sessionStorage.getItem("checkCount") : 0;
        var scriptFlag = this.getQueryString('scriptFlag');
        if(this.stringTrim(args.BROADCAST_OPTION.name) === '练习完成继续学习'){
            scriptFlag!=='T'&&window.showGemAnimation("practiceAward",true);
            var app = parent.window.apps;
            if(app){
                app.practiceEnd(checkCount);
            }

            if (window.webkit && window.webkit.messageHandlers) {
                var jsonDict = {
                    "act" : 'scratchFinish',
                    "totalTries" : checkCount
                };
                //注意，iOS的postMessage方法只接收一个参数，如果传多个参数，那么WKScriptMessage的body只接收到第一个参数
                 window.webkit.messageHandlers.scratchFinish.postMessage(jsonDict);
            }
        }

        if(typeof practiceId != "undefined" && practiceId != null && practiceId != ""){
            if(this.stringTrim(args.BROADCAST_OPTION.name) === '练习完成继续学习' && scriptFlag !== 'T'){
                window.showGemAnimation("practiceAward",true);
                window.handleCompleteExercise()
            }
        }
        if(this.stringTrim(args.BROADCAST_OPTION.name) === 'z再接再厉'){
            window.winhandlePlayGuide(false,false);
            if(window.parent&&window.parent["succeed"]){
                window.parent["succeed"]();
            }
        }
        if(this.stringTrim(args.BROADCAST_OPTION.name) === '结果正确'){
            window.listenBroadcast(true);
        }

        const broadcastVar = util.runtime.getTargetForStage().lookupBroadcastMsg(
            args.BROADCAST_OPTION.id, args.BROADCAST_OPTION.name);
        if (broadcastVar) {
            const broadcastOption = broadcastVar.name;
            // Have we run before, starting threads?
            if (!util.stackFrame.startedThreads) {
                // No - start hats for this broadcast.
                util.stackFrame.startedThreads = util.startHats(
                    'event_whenbroadcastreceived', {
                        BROADCAST_OPTION: broadcastOption
                    }
                );
                if (util.stackFrame.startedThreads.length === 0) {
                    // Nothing was started.
                    return;
                }
            }
            // We've run before; check if the wait is still going on.
            const instance = this;
            // Scratch 2 considers threads to be waiting if they are still in
            // runtime.threads. Threads that have run all their blocks, or are
            // marked done but still in runtime.threads are still considered to
            // be waiting.
            const waiting = util.stackFrame.startedThreads
                .some(thread => instance.runtime.threads.indexOf(thread) !== -1);
            if (waiting) {
                // If all threads are waiting for the next tick or later yield
                // for a tick as well. Otherwise yield until the next loop of
                // the threads.
                if (
                    util.stackFrame.startedThreads
                        .every(thread => instance.runtime.isWaitingThread(thread))
                ) {
                    util.yieldTick();
                } else {
                    util.yield();
                }
            }
        }
    }

    doNextLesson (args, util) {
        window.bridge.emit('exitEditor');
    }
}

module.exports = Scratch3EventBlocks;
