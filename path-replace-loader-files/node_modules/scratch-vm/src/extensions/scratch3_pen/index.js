const ArgumentType = require('../../extension-support/argument-type');
const BlockType = require('../../extension-support/block-type');
const TargetType = require('../../extension-support/target-type');
const Cast = require('../../util/cast');
const Clone = require('../../util/clone');
const Color = require('../../util/color');
const formatMessage = require('format-message');
const MathUtil = require('../../util/math-util');
const RenderedTarget = require('../../sprites/rendered-target');
const log = require('../../util/log');
const StageLayering = require('../../engine/stage-layering');

/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
const blockIconURI = 'data:image/png;base64,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'

/**
 * Enum for pen color parameter values.
 * @readonly
 * @enum {string}
 */
const ColorParam = {
    COLOR: 'color',
    SATURATION: 'saturation',
    BRIGHTNESS: 'brightness',
    TRANSPARENCY: 'transparency'
};

/**
 * @typedef {object} PenState - the pen state associated with a particular target.
 * @property {Boolean} penDown - tracks whether the pen should draw for this target.
 * @property {number} color - the current color (hue) of the pen.
 * @property {PenAttributes} penAttributes - cached pen attributes for the renderer. This is the authoritative value for
 *   diameter but not for pen color.
 */

/**
 * Host for the Pen-related blocks in Scratch 3.0
 * @param {Runtime} runtime - the runtime instantiating this block package.
 * @constructor
 */
class Scratch3PenBlocks {
    constructor (runtime) {
        /**
         * The runtime instantiating this block package.
         * @type {Runtime}
         */
        this.runtime = runtime;

        /**
         * The ID of the renderer Drawable corresponding to the pen layer.
         * @type {int}
         * @private
         */
        this._penDrawableId = -1;

        /**
         * The ID of the renderer Skin corresponding to the pen layer.
         * @type {int}
         * @private
         */
        this._penSkinId = -1;

        this._onTargetCreated = this._onTargetCreated.bind(this);
        this._onTargetMoved = this._onTargetMoved.bind(this);

        runtime.on('targetWasCreated', this._onTargetCreated);
        runtime.on('RUNTIME_DISPOSED', this.clear.bind(this));
    }

    /**
     * The default pen state, to be used when a target has no existing pen state.
     * @type {PenState}
     */
    static get DEFAULT_PEN_STATE () {
        return {
            penDown: false,
            color: 66.66,
            saturation: 100,
            brightness: 100,
            transparency: 0,
            _shade: 50, // Used only for legacy `change shade by` blocks
            penAttributes: {
                color4f: [0, 0, 1, 1],
                diameter: 1
            }
        };
    }


    /**
     * The minimum and maximum allowed pen size.
     * The maximum is twice the diagonal of the stage, so that even an
     * off-stage sprite can fill it.
     * @type {{min: number, max: number}}
     */
    static get PEN_SIZE_RANGE () {
        return {min: 1, max: 1200};
    }

    /**
     * The key to load & store a target's pen-related state.
     * @type {string}
     */
    static get STATE_KEY () {
        return 'Scratch.pen';
    }

    /**
     * Clamp a pen size value to the range allowed by the pen.
     * @param {number} requestedSize - the requested pen size.
     * @returns {number} the clamped size.
     * @private
     */
    _clampPenSize (requestedSize) {
        return MathUtil.clamp(
            requestedSize,
            Scratch3PenBlocks.PEN_SIZE_RANGE.min,
            Scratch3PenBlocks.PEN_SIZE_RANGE.max
        );
    }

    /**
     * Retrieve the ID of the renderer "Skin" corresponding to the pen layer. If
     * the pen Skin doesn't yet exist, create it.
     * @returns {int} the Skin ID of the pen layer, or -1 on failure.
     * @private
     */
    _getPenLayerID () {
        if (this._penSkinId < 0 && this.runtime.renderer) {
            this._penSkinId = this.runtime.renderer.createPenSkin();
            this._penDrawableId = this.runtime.renderer.createDrawable(StageLayering.PEN_LAYER);
            this.runtime.renderer.updateDrawableSkinId(this._penDrawableId, this._penSkinId);
        }
        return this._penSkinId;
    }

    /**
     * @param {Target} target - collect pen state for this target. Probably, but not necessarily, a RenderedTarget.
     * @returns {PenState} the mutable pen state associated with that target. This will be created if necessary.
     * @private
     */
    _getPenState (target) {
        let penState = target.getCustomState(Scratch3PenBlocks.STATE_KEY);
        if (!penState) {
            penState = Clone.simple(Scratch3PenBlocks.DEFAULT_PEN_STATE);
            target.setCustomState(Scratch3PenBlocks.STATE_KEY, penState);
        }
        return penState;
    }

    /**
     * When a pen-using Target is cloned, clone the pen state.
     * @param {Target} newTarget - the newly created target.
     * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
     * @listens Runtime#event:targetWasCreated
     * @private
     */
    _onTargetCreated (newTarget, sourceTarget) {
        if (sourceTarget) {
            const penState = sourceTarget.getCustomState(Scratch3PenBlocks.STATE_KEY);
            if (penState) {
                newTarget.setCustomState(Scratch3PenBlocks.STATE_KEY, Clone.simple(penState));
                if (penState.penDown) {
                    newTarget.addListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
                }
            }
        }
    }

    /**
     * Handle a target which has moved. This only fires when the pen is down.
     * @param {RenderedTarget} target - the target which has moved.
     * @param {number} oldX - the previous X position.
     * @param {number} oldY - the previous Y position.
     * @param {boolean} isForce - whether the movement was forced.
     * @private
     */
    _onTargetMoved (target, oldX, oldY, isForce) {
        // Only move the pen if the movement isn't forced (ie. dragged).
        if (!isForce) {
            const penSkinId = this._getPenLayerID();
            if (penSkinId >= 0) {
                const penState = this._getPenState(target);
                this.runtime.renderer.penLine(penSkinId, penState.penAttributes, oldX, oldY, target.x, target.y);
                this.runtime.requestRedraw();
            }
        }
    }

    /**
     * Wrap a color input into the range (0,100).
     * @param {number} value - the value to be wrapped.
     * @returns {number} the wrapped value.
     * @private
     */
    _wrapColor (value) {
        return MathUtil.wrapClamp(value, 0, 100);
    }

    /**
     * Initialize color parameters menu with localized strings
     * @returns {array} of the localized text and values for each menu element
     * @private
     */
    _initColorParam () {
        return [
            {
                text: formatMessage({
                    id: 'pen.colorMenu.color',
                    default: 'color',
                    description: 'label for color element in color picker for pen extension'
                }),
                value: ColorParam.COLOR
            },
            {
                text: formatMessage({
                    id: 'pen.colorMenu.saturation',
                    default: 'saturation',
                    description: 'label for saturation element in color picker for pen extension'
                }),
                value: ColorParam.SATURATION
            },
            {
                text: formatMessage({
                    id: 'pen.colorMenu.brightness',
                    default: 'brightness',
                    description: 'label for brightness element in color picker for pen extension'
                }),
                value: ColorParam.BRIGHTNESS
            },
            {
                text: formatMessage({
                    id: 'pen.colorMenu.transparency',
                    default: 'transparency',
                    description: 'label for transparency element in color picker for pen extension'
                }),
                value: ColorParam.TRANSPARENCY

            }
        ];
    }

    /**
     * Clamp a pen color parameter to the range (0,100).
     * @param {number} value - the value to be clamped.
     * @returns {number} the clamped value.
     * @private
     */
    _clampColorParam (value) {
        return MathUtil.clamp(value, 0, 100);
    }

    /**
     * Convert an alpha value to a pen transparency value.
     * Alpha ranges from 0 to 1, where 0 is transparent and 1 is opaque.
     * Transparency ranges from 0 to 100, where 0 is opaque and 100 is transparent.
     * @param {number} alpha - the input alpha value.
     * @returns {number} the transparency value.
     * @private
     */
    _alphaToTransparency (alpha) {
        return (1.0 - alpha) * 100.0;
    }

    /**
     * Convert a pen transparency value to an alpha value.
     * Alpha ranges from 0 to 1, where 0 is transparent and 1 is opaque.
     * Transparency ranges from 0 to 100, where 0 is opaque and 100 is transparent.
     * @param {number} transparency - the input transparency value.
     * @returns {number} the alpha value.
     * @private
     */
    _transparencyToAlpha (transparency) {
        return 1.0 - (transparency / 100.0);
    }

    /**
     * @returns {object} metadata for this extension and its blocks.
     */
    getInfo () {
        return {
            id: 'pen',
            name: formatMessage({
                id: 'pen.categoryName',
                default: 'Pen',
                description: 'Label for the pen extension category'
            }),
            blockIconURI: blockIconURI,
            blocks: [
                {
                    opcode: 'clear',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.clear',
                        default: 'erase all',
                        description: 'erase all pen trails and stamps'
                    })
                },
                {
                    opcode: 'stamp',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.stamp',
                        default: 'stamp',
                        description: 'render current costume on the background'
                    }),
                    filter: [TargetType.SPRITE]
                },
                {
                    opcode: 'penDown',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.penDown',
                        default: 'pen down',
                        description: 'start leaving a trail when the sprite moves'
                    }),
                    filter: [TargetType.SPRITE]
                },
                {
                    opcode: 'penUp',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.penUp',
                        default: 'pen up',
                        description: 'stop leaving a trail behind the sprite'
                    }),
                    filter: [TargetType.SPRITE]
                },
                {
                    opcode: 'setPenColorToColor',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.setColor',
                        default: 'set pen color to [COLOR]',
                        description: 'set the pen color to a particular (RGB) value'
                    }),
                    arguments: {
                        COLOR: {
                            type: ArgumentType.COLOR
                        }
                    },
                    filter: [TargetType.SPRITE]
                },
                {
                    opcode: 'changePenColorParamBy',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.changeColorParam',
                        default: 'change pen [COLOR_PARAM] by [VALUE]',
                        description: 'change the state of a pen color parameter'
                    }),
                    arguments: {
                        COLOR_PARAM: {
                            type: ArgumentType.STRING,
                            menu: 'colorParam',
                            defaultValue: ColorParam.COLOR
                        },
                        VALUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 10
                        }
                    },
                    filter: [TargetType.SPRITE]
                },
                {
                    opcode: 'setPenColorParamTo',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.setColorParam',
                        default: 'set pen [COLOR_PARAM] to [VALUE]',
                        description: 'set the state for a pen color parameter e.g. saturation'
                    }),
                    arguments: {
                        COLOR_PARAM: {
                            type: ArgumentType.STRING,
                            menu: 'colorParam',
                            defaultValue: ColorParam.COLOR
                        },
                        VALUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 50
                        }
                    },
                    filter: [TargetType.SPRITE]
                },
                {
                    opcode: 'changePenSizeBy',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.changeSize',
                        default: 'change pen size by [SIZE]',
                        description: 'change the diameter of the trail left by a sprite'
                    }),
                    arguments: {
                        SIZE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 1
                        }
                    },
                    filter: [TargetType.SPRITE]
                },
                {
                    opcode: 'setPenSizeTo',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.setSize',
                        default: 'set pen size to [SIZE]',
                        description: 'set the diameter of a trail left by a sprite'
                    }),
                    arguments: {
                        SIZE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 1
                        }
                    },
                    filter: [TargetType.SPRITE]
                },
                /* Legacy blocks, should not be shown in flyout */
                {
                    opcode: 'setPenShadeToNumber',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.setShade',
                        default: 'set pen shade to [SHADE]',
                        description: 'legacy pen blocks - set pen shade'
                    }),
                    arguments: {
                        SHADE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 1
                        }
                    },
                    hideFromPalette: true
                },
                {
                    opcode: 'changePenShadeBy',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.changeShade',
                        default: 'change pen shade by [SHADE]',
                        description: 'legacy pen blocks - change pen shade'
                    }),
                    arguments: {
                        SHADE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 1
                        }
                    },
                    hideFromPalette: true
                },
                {
                    opcode: 'setPenHueToNumber',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.setHue',
                        default: 'set pen color to [HUE]',
                        description: 'legacy pen blocks - set pen color to number'
                    }),
                    arguments: {
                        HUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 1
                        }
                    },
                    hideFromPalette: true
                },
                {
                    opcode: 'changePenHueBy',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.changeHue',
                        default: 'change pen color by [HUE]',
                        description: 'legacy pen blocks - change pen color'
                    }),
                    arguments: {
                        HUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 1
                        }
                    },
                    hideFromPalette: true
                }
            ],
            menus: {
                colorParam: {
                    acceptReporters: true,
                    items: this._initColorParam()
                }
            }
        };
    }

    /**
     * The pen "clear" block clears the pen layer's contents.
     */
    clear () {
        const penSkinId = this._getPenLayerID();
        if (penSkinId >= 0) {
            this.runtime.renderer.penClear(penSkinId);
            this.runtime.requestRedraw();
        }
    }

    /**
     * The pen "stamp" block stamps the current drawable's image onto the pen layer.
     * @param {object} args - the block arguments.
     * @param {object} util - utility object provided by the runtime.
     */
    stamp (args, util) {
        const penSkinId = this._getPenLayerID();
        if (penSkinId >= 0) {
            const target = util.target;
            this.runtime.renderer.penStamp(penSkinId, target.drawableID);
            this.runtime.requestRedraw();
        }
    }

    /**
     * The pen "pen down" block causes the target to leave pen trails on future motion.
     * @param {object} args - the block arguments.
     * @param {object} util - utility object provided by the runtime.
     */
    penDown (args, util) {
        const target = util.target;
        const penState = this._getPenState(target);

        if (!penState.penDown) {
            penState.penDown = true;
            target.addListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
        }

        const penSkinId = this._getPenLayerID();
        if (penSkinId >= 0) {
            this.runtime.renderer.penPoint(penSkinId, penState.penAttributes, target.x, target.y);
            this.runtime.requestRedraw();
        }
    }

    /**
     * The pen "pen up" block stops the target from leaving pen trails.
     * @param {object} args - the block arguments.
     * @param {object} util - utility object provided by the runtime.
     */
    penUp (args, util) {
        const target = util.target;
        const penState = this._getPenState(target);

        if (penState.penDown) {
            penState.penDown = false;
            target.removeListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
        }
    }

    /**
     * The pen "set pen color to {color}" block sets the pen to a particular RGB color.
     * The transparency is reset to 0.
     * @param {object} args - the block arguments.
     *  @property {int} COLOR - the color to set, expressed as a 24-bit RGB value (0xRRGGBB).
     * @param {object} util - utility object provided by the runtime.
     */
    setPenColorToColor (args, util) {
        const penState = this._getPenState(util.target);
        const rgb = Cast.toRgbColorObject(args.COLOR);
        const hsv = Color.rgbToHsv(rgb);
        penState.color = (hsv.h / 360) * 100;
        penState.saturation = hsv.s * 100;
        penState.brightness = hsv.v * 100;
        if (rgb.hasOwnProperty('a')) {
            penState.transparency = 100 * (1 - (rgb.a / 255.0));
        } else {
            penState.transparency = 0;
        }

        // Set the legacy "shade" value the same way scratch 2 did.
        penState._shade = penState.brightness / 2;

        this._updatePenColor(penState);
    }

    /**
     * Update the cached color from the color, saturation, brightness and transparency values
     * in the provided PenState object.
     * @param {PenState} penState - the pen state to update.
     * @private
     */
    _updatePenColor (penState) {
        const rgb = Color.hsvToRgb({
            h: penState.color * 360 / 100,
            s: penState.saturation / 100,
            v: penState.brightness / 100
        });
        penState.penAttributes.color4f[0] = rgb.r / 255.0;
        penState.penAttributes.color4f[1] = rgb.g / 255.0;
        penState.penAttributes.color4f[2] = rgb.b / 255.0;
        penState.penAttributes.color4f[3] = this._transparencyToAlpha(penState.transparency);
    }

    /**
     * Set or change a single color parameter on the pen state, and update the pen color.
     * @param {ColorParam} param - the name of the color parameter to set or change.
     * @param {number} value - the value to set or change the param by.
     * @param {PenState} penState - the pen state to update.
     * @param {boolean} change - if true change param by value, if false set param to value.
     * @private
     */
    _setOrChangeColorParam (param, value, penState, change) {
        switch (param) {
        case ColorParam.COLOR:
            penState.color = this._wrapColor(value + (change ? penState.color : 0));
            break;
        case ColorParam.SATURATION:
            penState.saturation = this._clampColorParam(value + (change ? penState.saturation : 0));
            break;
        case ColorParam.BRIGHTNESS:
            penState.brightness = this._clampColorParam(value + (change ? penState.brightness : 0));
            break;
        case ColorParam.TRANSPARENCY:
            penState.transparency = this._clampColorParam(value + (change ? penState.transparency : 0));
            break;
        default:
            log.warn(`Tried to set or change unknown color parameter: ${param}`);
        }
        this._updatePenColor(penState);
    }

    /**
     * The "change pen {ColorParam} by {number}" block changes one of the pen's color parameters
     * by a given amound.
     * @param {object} args - the block arguments.
     *  @property {ColorParam} COLOR_PARAM - the name of the selected color parameter.
     *  @property {number} VALUE - the amount to change the selected parameter by.
     * @param {object} util - utility object provided by the runtime.
     */
    changePenColorParamBy (args, util) {
        const penState = this._getPenState(util.target);
        this._setOrChangeColorParam(args.COLOR_PARAM, Cast.toNumber(args.VALUE), penState, true);
    }

    /**
     * The "set pen {ColorParam} to {number}" block sets one of the pen's color parameters
     * to a given amound.
     * @param {object} args - the block arguments.
     *  @property {ColorParam} COLOR_PARAM - the name of the selected color parameter.
     *  @property {number} VALUE - the amount to set the selected parameter to.
     * @param {object} util - utility object provided by the runtime.
     */
    setPenColorParamTo (args, util) {
        const penState = this._getPenState(util.target);
        this._setOrChangeColorParam(args.COLOR_PARAM, Cast.toNumber(args.VALUE), penState, false);
    }

    /**
     * The pen "change pen size by {number}" block changes the pen size by the given amount.
     * @param {object} args - the block arguments.
     *  @property {number} SIZE - the amount of desired size change.
     * @param {object} util - utility object provided by the runtime.
     */
    changePenSizeBy (args, util) {
        const penAttributes = this._getPenState(util.target).penAttributes;
        penAttributes.diameter = this._clampPenSize(penAttributes.diameter + Cast.toNumber(args.SIZE));
    }

    /**
     * The pen "set pen size to {number}" block sets the pen size to the given amount.
     * @param {object} args - the block arguments.
     *  @property {number} SIZE - the amount of desired size change.
     * @param {object} util - utility object provided by the runtime.
     */
    setPenSizeTo (args, util) {
        const penAttributes = this._getPenState(util.target).penAttributes;
        penAttributes.diameter = this._clampPenSize(Cast.toNumber(args.SIZE));
    }

    /* LEGACY OPCODES */
    /**
     * Scratch 2 "hue" param is equivelant to twice the new "color" param.
     * @param {object} args - the block arguments.
     *  @property {number} HUE - the amount to set the hue to.
     * @param {object} util - utility object provided by the runtime.
     */
    setPenHueToNumber (args, util) {
        const penState = this._getPenState(util.target);
        const hueValue = Cast.toNumber(args.HUE);
        const colorValue = hueValue / 2;
        this._setOrChangeColorParam(ColorParam.COLOR, colorValue, penState, false);
        this._setOrChangeColorParam(ColorParam.TRANSPARENCY, 0, penState, false);
        this._legacyUpdatePenColor(penState);
    }

    /**
     * Scratch 2 "hue" param is equivelant to twice the new "color" param.
     * @param {object} args - the block arguments.
     *  @property {number} HUE - the amount of desired hue change.
     * @param {object} util - utility object provided by the runtime.
     */
    changePenHueBy (args, util) {
        const penState = this._getPenState(util.target);
        const hueChange = Cast.toNumber(args.HUE);
        const colorChange = hueChange / 2;
        this._setOrChangeColorParam(ColorParam.COLOR, colorChange, penState, true);

        this._legacyUpdatePenColor(penState);
    }

    /**
     * Use legacy "set shade" code to calculate RGB value for shade,
     * then convert back to HSV and store those components.
     * It is important to also track the given shade in penState._shade
     * because it cannot be accurately backed out of the new HSV later.
     * @param {object} args - the block arguments.
     *  @property {number} SHADE - the amount to set the shade to.
     * @param {object} util - utility object provided by the runtime.
     */
    setPenShadeToNumber (args, util) {
        const penState = this._getPenState(util.target);
        let newShade = Cast.toNumber(args.SHADE);

        // Wrap clamp the new shade value the way scratch 2 did.
        newShade = newShade % 200;
        if (newShade < 0) newShade += 200;

        // And store the shade that was used to compute this new color for later use.
        penState._shade = newShade;

        this._legacyUpdatePenColor(penState);
    }

    /**
     * Because "shade" cannot be backed out of hsv consistently, use the previously
     * stored penState._shade to make the shade change.
     * @param {object} args - the block arguments.
     *  @property {number} SHADE - the amount of desired shade change.
     * @param {object} util - utility object provided by the runtime.
     */
    changePenShadeBy (args, util) {
        const penState = this._getPenState(util.target);
        const shadeChange = Cast.toNumber(args.SHADE);
        this.setPenShadeToNumber({SHADE: penState._shade + shadeChange}, util);
    }

    /**
     * Update the pen state's color from its hue & shade values, Scratch 2.0 style.
     * @param {object} penState - update the HSV & RGB values in this pen state from its hue & shade values.
     * @private
     */
    _legacyUpdatePenColor (penState) {
        // Create the new color in RGB using the scratch 2 "shade" model
        let rgb = Color.hsvToRgb({h: penState.color * 360 / 100, s: 1, v: 1});
        const shade = (penState._shade > 100) ? 200 - penState._shade : penState._shade;
        if (shade < 50) {
            rgb = Color.mixRgb(Color.RGB_BLACK, rgb, (10 + shade) / 60);
        } else {
            rgb = Color.mixRgb(rgb, Color.RGB_WHITE, (shade - 50) / 60);
        }

        // Update the pen state according to new color
        const hsv = Color.rgbToHsv(rgb);
        penState.color = 100 * hsv.h / 360;
        penState.saturation = 100 * hsv.s;
        penState.brightness = 100 * hsv.v;

        this._updatePenColor(penState);
    }
}

module.exports = Scratch3PenBlocks;
