const ArgumentType = require('../../extension-support/argument-type');
const BlockType = require('../../extension-support/block-type');
const TargetType = require('../../extension-support/target-type');
const Cast = require('../../util/cast');
const Clone = require('../../util/clone');
const Color = require('../../util/color');
const formatMessage = require('format-message');
const MathUtil = require('../../util/math-util');
const RenderedTarget = require('../../sprites/rendered-target');
const log = require('../../util/log');
const StageLayering = require('../../engine/stage-layering');

/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
const blockIconURI = 'data:image/png;base64,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'
/**
 * Enum for pen color parameter values.
 * @readonly
 * @enum {string}
 */
const ColorParam = {
    COLOR: 'color',
    SATURATION: 'saturation',
    BRIGHTNESS: 'brightness',
    TRANSPARENCY: 'transparency'
};

/**
 * @typedef {object} PenState - the pen state associated with a particular target.
 * @property {Boolean} penDown - tracks whether the pen should draw for this target.
 * @property {number} color - the current color (hue) of the pen.
 * @property {PenAttributes} penAttributes - cached pen attributes for the renderer. This is the authoritative value for
 *   diameter but not for pen color.
 */

/**
 * Host for the Pen-related blocks in Scratch 3.0
 * @param {Runtime} runtime - the runtime instantiating this block package.
 * @constructor
 */
class Scratch3PenBlocks {
    constructor (runtime) {
        /**
         * The runtime instantiating this block package.
         * @type {Runtime}
         */
        this.runtime = runtime;

        /**
         * The ID of the renderer Drawable corresponding to the pen layer.
         * @type {int}
         * @private
         */
        this._penDrawableId = -1;

        /**
         * The ID of the renderer Skin corresponding to the pen layer.
         * @type {int}
         * @private
         */
        this._penSkinId = -1;

        this._onTargetCreated = this._onTargetCreated.bind(this);
        this._onTargetMoved = this._onTargetMoved.bind(this);

        runtime.on('targetWasCreated', this._onTargetCreated);
        let clearFun = this.clear.bind(this);
        runtime.on('RUNTIME_DISPOSED', clearFun);
        runtime.on('PROJECT_RUN_STOP', clearFun);
    }

    /**
     * The default pen state, to be used when a target has no existing pen state.
     * @type {PenState}
     */
    static get DEFAULT_PEN_STATE () {
        return {
            penDown: false,
            color: 66.66,
            saturation: 100,
            brightness: 100,
            transparency: 0,
            _shade: 50, // Used only for legacy `change shade by` blocks
            penAttributes: {
                color4f: [0, 0, 1, 1],
                diameter: 1
            }
        };
    }


    /**
     * The minimum and maximum allowed pen size.
     * The maximum is twice the diagonal of the stage, so that even an
     * off-stage sprite can fill it.
     * @type {{min: number, max: number}}
     */
    static get PEN_SIZE_RANGE () {
        return {min: 1, max: 1200};
    }

    /**
     * The key to load & store a target's pen-related state.
     * @type {string}
     */
    static get STATE_KEY () {
        return 'Scratch.pen';
    }

    /**
     * Clamp a pen size value to the range allowed by the pen.
     * @param {number} requestedSize - the requested pen size.
     * @returns {number} the clamped size.
     * @private
     */
    _clampPenSize (requestedSize) {
        return MathUtil.clamp(
            requestedSize,
            Scratch3PenBlocks.PEN_SIZE_RANGE.min,
            Scratch3PenBlocks.PEN_SIZE_RANGE.max
        );
    }

    /**
     * Retrieve the ID of the renderer "Skin" corresponding to the pen layer. If
     * the pen Skin doesn't yet exist, create it.
     * @returns {int} the Skin ID of the pen layer, or -1 on failure.
     * @private
     */
    _getPenLayerID () {
        if (this.runtime.renderer) {
            if(this._penSkinId < 0 || !this.runtime.renderer._allSkins[this._penSkinId]){
                if(this._penDrawableId > -1){
                    this.runtime.renderer.destroyDrawable(this._penDrawableId, StageLayering.PEN_LAYER);
                }
                this._penSkinId = this.runtime.renderer.createPenSkin();
                this._penDrawableId = this.runtime.renderer.createDrawable(StageLayering.PEN_LAYER);
                this.runtime.renderer.updateDrawableSkinId(this._penDrawableId, this._penSkinId);
            }
            
        }
        return this._penSkinId;
    }

    /**
     * @param {Target} target - collect pen state for this target. Probably, but not necessarily, a RenderedTarget.
     * @returns {PenState} the mutable pen state associated with that target. This will be created if necessary.
     * @private
     */
    _getPenState (target) {
        let penState = target.getCustomState(Scratch3PenBlocks.STATE_KEY);
        if (!penState) {
            penState = Clone.simple(Scratch3PenBlocks.DEFAULT_PEN_STATE);
            target.setCustomState(Scratch3PenBlocks.STATE_KEY, penState);
        }
        return penState;
    }

    /**
     * When a pen-using Target is cloned, clone the pen state.
     * @param {Target} newTarget - the newly created target.
     * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
     * @listens Runtime#event:targetWasCreated
     * @private
     */
    _onTargetCreated (newTarget, sourceTarget) {
        if (sourceTarget) {
            const penState = sourceTarget.getCustomState(Scratch3PenBlocks.STATE_KEY);
            if (penState) {
                newTarget.setCustomState(Scratch3PenBlocks.STATE_KEY, Clone.simple(penState));
                if (penState.penDown) {
                    newTarget.addListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
                }
            }
        }
    }

    /**
     * Handle a target which has moved. This only fires when the pen is down.
     * @param {RenderedTarget} target - the target which has moved.
     * @param {number} oldX - the previous X position.
     * @param {number} oldY - the previous Y position.
     * @param {boolean} isForce - whether the movement was forced.
     * @private
     */
    _onTargetMoved (target, oldX, oldY, isForce) {
        // Only move the pen if the movement isn't forced (ie. dragged).
        if (!isForce) {
            const penSkinId = this._getPenLayerID();
            if (penSkinId >= 0) {
                const penState = this._getPenState(target);
                this.runtime.renderer.penLine(penSkinId, penState.penAttributes, oldX, oldY, target.x, target.y);
                this.runtime.requestRedraw();
            }
        }
    }

    /**
     * Wrap a color input into the range (0,100).
     * @param {number} value - the value to be wrapped.
     * @returns {number} the wrapped value.
     * @private
     */
    _wrapColor (value) {
        return MathUtil.wrapClamp(value, 0, 100);
    }

    /**
     * Initialize color parameters menu with localized strings
     * @returns {array} of the localized text and values for each menu element
     * @private
     */
    _initColorParam () {
        return [
            {
                text: formatMessage({
                    id: 'pen.colorMenu.color',
                    default: 'color',
                    description: 'label for color element in color picker for pen extension'
                }),
                value: ColorParam.COLOR
            },
            {
                text: formatMessage({
                    id: 'pen.colorMenu.saturation',
                    default: 'saturation',
                    description: 'label for saturation element in color picker for pen extension'
                }),
                value: ColorParam.SATURATION
            },
            {
                text: formatMessage({
                    id: 'pen.colorMenu.brightness',
                    default: 'brightness',
                    description: 'label for brightness element in color picker for pen extension'
                }),
                value: ColorParam.BRIGHTNESS
            },
            {
                text: formatMessage({
                    id: 'pen.colorMenu.transparency',
                    default: 'transparency',
                    description: 'label for transparency element in color picker for pen extension'
                }),
                value: ColorParam.TRANSPARENCY

            }
        ];
    }

    /**
     * Clamp a pen color parameter to the range (0,100).
     * @param {number} value - the value to be clamped.
     * @returns {number} the clamped value.
     * @private
     */
    _clampColorParam (value) {
        return MathUtil.clamp(value, 0, 100);
    }

    /**
     * Convert an alpha value to a pen transparency value.
     * Alpha ranges from 0 to 1, where 0 is transparent and 1 is opaque.
     * Transparency ranges from 0 to 100, where 0 is opaque and 100 is transparent.
     * @param {number} alpha - the input alpha value.
     * @returns {number} the transparency value.
     * @private
     */
    _alphaToTransparency (alpha) {
        return (1.0 - alpha) * 100.0;
    }

    /**
     * Convert a pen transparency value to an alpha value.
     * Alpha ranges from 0 to 1, where 0 is transparent and 1 is opaque.
     * Transparency ranges from 0 to 100, where 0 is opaque and 100 is transparent.
     * @param {number} transparency - the input transparency value.
     * @returns {number} the alpha value.
     * @private
     */
    _transparencyToAlpha (transparency) {
        return 1.0 - (transparency / 100.0);
    }

    /**
     * @returns {object} metadata for this extension and its blocks.
     */
    getInfo () {
        return {
            id: 'pen',
            name: formatMessage({
                id: 'pen.categoryName',
                default: 'Pen',
                description: 'Label for the pen extension category'
            }),
            blockIconURI: blockIconURI,
            blocks: [
                {
                    opcode: 'clear',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.clear',
                        default: 'erase all',
                        description: 'erase all pen trails and stamps'
                    })
                },
                {
                    opcode: 'stamp',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.stamp',
                        default: 'stamp',
                        description: 'render current costume on the background'
                    }),
                    filter: [TargetType.SPRITE]
                },
                {
                    opcode: 'penDown',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.penDown',
                        default: 'pen down',
                        description: 'start leaving a trail when the sprite moves'
                    }),
                    filter: [TargetType.SPRITE]
                },
                {
                    opcode: 'penUp',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.penUp',
                        default: 'pen up',
                        description: 'stop leaving a trail behind the sprite'
                    }),
                    filter: [TargetType.SPRITE]
                },
                {
                    opcode: 'setPenColorToColor',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.setColor',
                        default: 'set pen color to [COLOR]',
                        description: 'set the pen color to a particular (RGB) value'
                    }),
                    arguments: {
                        COLOR: {
                            type: ArgumentType.COLOR
                        }
                    },
                    filter: [TargetType.SPRITE]
                },
                {
                    opcode: 'changePenColorParamBy',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.changeColorParam',
                        default: 'change pen [COLOR_PARAM] by [VALUE]',
                        description: 'change the state of a pen color parameter'
                    }),
                    arguments: {
                        COLOR_PARAM: {
                            type: ArgumentType.STRING,
                            menu: 'colorParam',
                            defaultValue: ColorParam.COLOR
                        },
                        VALUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 10
                        }
                    },
                    filter: [TargetType.SPRITE]
                },
                {
                    opcode: 'setPenColorParamTo',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.setColorParam',
                        default: 'set pen [COLOR_PARAM] to [VALUE]',
                        description: 'set the state for a pen color parameter e.g. saturation'
                    }),
                    arguments: {
                        COLOR_PARAM: {
                            type: ArgumentType.STRING,
                            menu: 'colorParam',
                            defaultValue: ColorParam.COLOR
                        },
                        VALUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 50
                        }
                    },
                    filter: [TargetType.SPRITE]
                },
                {
                    opcode: 'changePenSizeBy',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.changeSize',
                        default: 'change pen size by [SIZE]',
                        description: 'change the diameter of the trail left by a sprite'
                    }),
                    arguments: {
                        SIZE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 1
                        }
                    },
                    filter: [TargetType.SPRITE]
                },
                {
                    opcode: 'setPenSizeTo',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.setSize',
                        default: 'set pen size to [SIZE]',
                        description: 'set the diameter of a trail left by a sprite'
                    }),
                    arguments: {
                        SIZE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 1
                        }
                    },
                    filter: [TargetType.SPRITE]
                },
                /* Legacy blocks, should not be shown in flyout */
                {
                    opcode: 'setPenShadeToNumber',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.setShade',
                        default: 'set pen shade to [SHADE]',
                        description: 'legacy pen blocks - set pen shade'
                    }),
                    arguments: {
                        SHADE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 1
                        }
                    },
                    hideFromPalette: true
                },
                {
                    opcode: 'changePenShadeBy',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.changeShade',
                        default: 'change pen shade by [SHADE]',
                        description: 'legacy pen blocks - change pen shade'
                    }),
                    arguments: {
                        SHADE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 1
                        }
                    },
                    hideFromPalette: true
                },
                {
                    opcode: 'setPenHueToNumber',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.setHue',
                        default: 'set pen color to [HUE]',
                        description: 'legacy pen blocks - set pen color to number'
                    }),
                    arguments: {
                        HUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 1
                        }
                    },
                    hideFromPalette: true
                },
                {
                    opcode: 'changePenHueBy',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'pen.changeHue',
                        default: 'change pen color by [HUE]',
                        description: 'legacy pen blocks - change pen color'
                    }),
                    arguments: {
                        HUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 1
                        }
                    },
                    hideFromPalette: true
                }
            ],
            menus: {
                colorParam: {
                    acceptReporters: true,
                    items: this._initColorParam()
                }
            }
        };
    }

    /**
     * The pen "clear" block clears the pen layer's contents.
     */
    clear () {
        const penSkinId = this._penSkinId;
        if (penSkinId >= 0) {
            this.runtime.renderer.penClear(penSkinId);
            //this.runtime.renderer.destroyDrawable(this._penDrawableId, StageLayering.PEN_LAYER);
            //const penSkin = this.runtime.renderer._allSkins[penSkinId];
            //penSkin && penSkin.dispose();
            //delete this.runtime.renderer._allSkins[penSkinId];
            this.runtime.requestRedraw();
            //this._penSkinId = -1;
        }
    }

    /**
     * The pen "stamp" block stamps the current drawable's image onto the pen layer.
     * @param {object} args - the block arguments.
     * @param {object} util - utility object provided by the runtime.
     */
    stamp (args, util) {
        const penSkinId = this._getPenLayerID();
        if (penSkinId >= 0) {
            const target = util.target;
            this.runtime.renderer.penStamp(penSkinId, target.drawableID);
            this.runtime.requestRedraw();
        }
    }

    /**
     * The pen "pen down" block causes the target to leave pen trails on future motion.
     * @param {object} args - the block arguments.
     * @param {object} util - utility object provided by the runtime.
     */
    penDown (args, util) {
        const target = util.target;
        const penState = this._getPenState(target);

        if (!penState.penDown) {
            penState.penDown = true;
            target.addListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
        }

        const penSkinId = this._getPenLayerID();
        if (penSkinId >= 0) {
            this.runtime.renderer.penPoint(penSkinId, penState.penAttributes, target.x, target.y);
            this.runtime.requestRedraw();
        }
    }

    /**
     * The pen "pen up" block stops the target from leaving pen trails.
     * @param {object} args - the block arguments.
     * @param {object} util - utility object provided by the runtime.
     */
    penUp (args, util) {
        const target = util.target;
        const penState = this._getPenState(target);

        if (penState.penDown) {
            penState.penDown = false;
            target.removeListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
        }
    }

    /**
     * The pen "set pen color to {color}" block sets the pen to a particular RGB color.
     * The transparency is reset to 0.
     * @param {object} args - the block arguments.
     *  @property {int} COLOR - the color to set, expressed as a 24-bit RGB value (0xRRGGBB).
     * @param {object} util - utility object provided by the runtime.
     */
    setPenColorToColor (args, util) {
        const penState = this._getPenState(util.target);
        const rgb = Cast.toRgbColorObject(args.COLOR);
        const hsv = Color.rgbToHsv(rgb);
        penState.color = (hsv.h / 360) * 100;
        penState.saturation = hsv.s * 100;
        penState.brightness = hsv.v * 100;
        if (rgb.hasOwnProperty('a')) {
            penState.transparency = 100 * (1 - (rgb.a / 255.0));
        } else {
            penState.transparency = 0;
        }

        // Set the legacy "shade" value the same way scratch 2 did.
        penState._shade = penState.brightness / 2;

        this._updatePenColor(penState);
    }

    /**
     * Update the cached color from the color, saturation, brightness and transparency values
     * in the provided PenState object.
     * @param {PenState} penState - the pen state to update.
     * @private
     */
    _updatePenColor (penState) {
        const rgb = Color.hsvToRgb({
            h: penState.color * 360 / 100,
            s: penState.saturation / 100,
            v: penState.brightness / 100
        });
        penState.penAttributes.color4f[0] = rgb.r / 255.0;
        penState.penAttributes.color4f[1] = rgb.g / 255.0;
        penState.penAttributes.color4f[2] = rgb.b / 255.0;
        penState.penAttributes.color4f[3] = this._transparencyToAlpha(penState.transparency);
    }

    /**
     * Set or change a single color parameter on the pen state, and update the pen color.
     * @param {ColorParam} param - the name of the color parameter to set or change.
     * @param {number} value - the value to set or change the param by.
     * @param {PenState} penState - the pen state to update.
     * @param {boolean} change - if true change param by value, if false set param to value.
     * @private
     */
    _setOrChangeColorParam (param, value, penState, change) {
        switch (param) {
        case ColorParam.COLOR:
            penState.color = this._wrapColor(value + (change ? penState.color : 0));
            break;
        case ColorParam.SATURATION:
            penState.saturation = this._clampColorParam(value + (change ? penState.saturation : 0));
            break;
        case ColorParam.BRIGHTNESS:
            penState.brightness = this._clampColorParam(value + (change ? penState.brightness : 0));
            break;
        case ColorParam.TRANSPARENCY:
            penState.transparency = this._clampColorParam(value + (change ? penState.transparency : 0));
            break;
        default:
            log.warn(`Tried to set or change unknown color parameter: ${param}`);
        }
        this._updatePenColor(penState);
    }

    /**
     * The "change pen {ColorParam} by {number}" block changes one of the pen's color parameters
     * by a given amound.
     * @param {object} args - the block arguments.
     *  @property {ColorParam} COLOR_PARAM - the name of the selected color parameter.
     *  @property {number} VALUE - the amount to change the selected parameter by.
     * @param {object} util - utility object provided by the runtime.
     */
    changePenColorParamBy (args, util) {
        const penState = this._getPenState(util.target);
        this._setOrChangeColorParam(args.COLOR_PARAM, Cast.toNumber(args.VALUE), penState, true);
    }

    /**
     * The "set pen {ColorParam} to {number}" block sets one of the pen's color parameters
     * to a given amound.
     * @param {object} args - the block arguments.
     *  @property {ColorParam} COLOR_PARAM - the name of the selected color parameter.
     *  @property {number} VALUE - the amount to set the selected parameter to.
     * @param {object} util - utility object provided by the runtime.
     */
    setPenColorParamTo (args, util) {
        const penState = this._getPenState(util.target);
        this._setOrChangeColorParam(args.COLOR_PARAM, Cast.toNumber(args.VALUE), penState, false);
    }

    /**
     * The pen "change pen size by {number}" block changes the pen size by the given amount.
     * @param {object} args - the block arguments.
     *  @property {number} SIZE - the amount of desired size change.
     * @param {object} util - utility object provided by the runtime.
     */
    changePenSizeBy (args, util) {
        const penAttributes = this._getPenState(util.target).penAttributes;
        penAttributes.diameter = this._clampPenSize(penAttributes.diameter + Cast.toNumber(args.SIZE));
    }

    /**
     * The pen "set pen size to {number}" block sets the pen size to the given amount.
     * @param {object} args - the block arguments.
     *  @property {number} SIZE - the amount of desired size change.
     * @param {object} util - utility object provided by the runtime.
     */
    setPenSizeTo (args, util) {
        const penAttributes = this._getPenState(util.target).penAttributes;
        penAttributes.diameter = this._clampPenSize(Cast.toNumber(args.SIZE));
    }

    /* LEGACY OPCODES */
    /**
     * Scratch 2 "hue" param is equivelant to twice the new "color" param.
     * @param {object} args - the block arguments.
     *  @property {number} HUE - the amount to set the hue to.
     * @param {object} util - utility object provided by the runtime.
     */
    setPenHueToNumber (args, util) {
        const penState = this._getPenState(util.target);
        const hueValue = Cast.toNumber(args.HUE);
        const colorValue = hueValue / 2;
        this._setOrChangeColorParam(ColorParam.COLOR, colorValue, penState, false);
        this._setOrChangeColorParam(ColorParam.TRANSPARENCY, 0, penState, false);
        this._legacyUpdatePenColor(penState);
    }

    /**
     * Scratch 2 "hue" param is equivelant to twice the new "color" param.
     * @param {object} args - the block arguments.
     *  @property {number} HUE - the amount of desired hue change.
     * @param {object} util - utility object provided by the runtime.
     */
    changePenHueBy (args, util) {
        const penState = this._getPenState(util.target);
        const hueChange = Cast.toNumber(args.HUE);
        const colorChange = hueChange / 2;
        this._setOrChangeColorParam(ColorParam.COLOR, colorChange, penState, true);

        this._legacyUpdatePenColor(penState);
    }

    /**
     * Use legacy "set shade" code to calculate RGB value for shade,
     * then convert back to HSV and store those components.
     * It is important to also track the given shade in penState._shade
     * because it cannot be accurately backed out of the new HSV later.
     * @param {object} args - the block arguments.
     *  @property {number} SHADE - the amount to set the shade to.
     * @param {object} util - utility object provided by the runtime.
     */
    setPenShadeToNumber (args, util) {
        const penState = this._getPenState(util.target);
        let newShade = Cast.toNumber(args.SHADE);

        // Wrap clamp the new shade value the way scratch 2 did.
        newShade = newShade % 200;
        if (newShade < 0) newShade += 200;

        // And store the shade that was used to compute this new color for later use.
        penState._shade = newShade;

        this._legacyUpdatePenColor(penState);
    }

    /**
     * Because "shade" cannot be backed out of hsv consistently, use the previously
     * stored penState._shade to make the shade change.
     * @param {object} args - the block arguments.
     *  @property {number} SHADE - the amount of desired shade change.
     * @param {object} util - utility object provided by the runtime.
     */
    changePenShadeBy (args, util) {
        const penState = this._getPenState(util.target);
        const shadeChange = Cast.toNumber(args.SHADE);
        this.setPenShadeToNumber({SHADE: penState._shade + shadeChange}, util);
    }

    /**
     * Update the pen state's color from its hue & shade values, Scratch 2.0 style.
     * @param {object} penState - update the HSV & RGB values in this pen state from its hue & shade values.
     * @private
     */
    _legacyUpdatePenColor (penState) {
        // Create the new color in RGB using the scratch 2 "shade" model
        let rgb = Color.hsvToRgb({h: penState.color * 360 / 100, s: 1, v: 1});
        const shade = (penState._shade > 100) ? 200 - penState._shade : penState._shade;
        if (shade < 50) {
            rgb = Color.mixRgb(Color.RGB_BLACK, rgb, (10 + shade) / 60);
        } else {
            rgb = Color.mixRgb(rgb, Color.RGB_WHITE, (shade - 50) / 60);
        }

        // Update the pen state according to new color
        const hsv = Color.rgbToHsv(rgb);
        penState.color = 100 * hsv.h / 360;
        penState.saturation = 100 * hsv.s;
        penState.brightness = 100 * hsv.v;

        this._updatePenColor(penState);
    }
}

module.exports = Scratch3PenBlocks;
